### 1.CLR的执行模型

#### 1.1将源代码编译成托管模块

    公共语言运行时（Common Language Runtime,CLR）是一个可由多种编程语言使用的“运行时”。CLR的核心功能（比如内
    存管理、程序集加载、安全性、异常处理和线程同步）可由面向CLR的所有语言使用。

    事实上CLR根本不关心开发人员用哪一种语言来写源代码。这意味着在选择编程语言时，应选择最容易表达自己意图的语言。

    c#源代码文件----------->c#编译器---------->托管模块（中间语言和元数据）
    Basic源代码文件-------->Basic编译器------->托管模块（中间语言和元数据）
    IL源代码文件----------->c#编译器---------->托管模块（中间语言和元数据）

    如上所示，可用支持CLR的任何语言创建源代码文件，然后用对应的编译器检查语法和分析源代码。无论选择哪个编译器，结
    果都是托管模块（managed module）。
    
    托管模块：标准的32位Microsoft Windows可移植执行体（PE32）文件，或者是标准的64位Windows可移植执行体（PE32+）
    文件，他们都需要CLR才能执行。另外，托管程序集总是利用Windows的数据执行保护（Data Execution Prevention,DEP）
    和地址空间布局随机（Address Space Layout Randomization,ASL）,这两个功能旨在增强整个系统的安全性。

    托管模块的各个组成部分：

        PE32或PE32+头：标准WindowsPE头文件。如果这个头使用PE32格式，文件能在Windows的32位或者64位版本上运行。如
        果这个头使用了PE32+格式，文件只能在Windows的64位版本上运行。这个头还标识了文件类型，包括GUI,CUI或者DLL。

        CLR头：包含使这个模块成为托管模块的信息（可由CLR和一些实用程序进行解释）。头中包含要求的CLR版本，一些标志，
        托管模块入口方法（Main方法）的MethodDef元数据token以及模块的元数据、资源、强名称。

        元数据：每个托管模块都包含元数据表。主要有两种表：一种表描述源代码中定义的类型和成员，另一种描述源代码引用的
        类型和成员。

        IL（中间语言）代码：编译器编译源代码时生成的代码。在运行时，CLR将IL编译成本机CPU指令。

    本机代码编译器生成的是面向CPU架构（x86,x64或ARM）的代码。然而，每个面向CLR的编译器生成的都是IL（中间语言）代码。
    IL代码有时称为托管代码，因为CLR管理它的执行。

    元数据：简单的说就是一个数据表集合，一些数据表描述了模块中定义了什么（比如类型及其成员），另一些描述了模块引用了
    什么（比如导入的类型及其成员）。元数据总是与包含IL代码的文件关联，元数据总是嵌入和代码相同的EXE/DLL文件中，所以
    元数据和他描述的IL代码永远不会失去同步。

    元数据的用途：
        1.元数据避免了编译时对原生C/C++头和库文件的需求。
        2.Microsoft Visual Studio用元数据帮助你写代码。
        3.CLR的代码验证过程和使用元数据确保代码只执行“类型安全”的操作。
        4.元数据运行将对象的字段序列化到内存块，将其发送给另一台机器，然后反序列化。
        5.元数据允许垃圾回收器跟踪对象生存期。

    小结：
        不同的面向CLR的编程语言，经过自己的编译器的进行编译后，结果都会生成托管模块，托管模块主要包含4部分：PE32或PE32+
        头、CLR头、元数据、IL（中间语言代码），其中PE32或PE32+头和CLR头其实包含的是所要运行的环境的要求，元数据包含了
        类型和成员，而IL（中间语言）代码，在运行时，CLR进一步将IL编译成本机CPU指令。

#### 1.2将托管模块合并成程序集

    CLR实际不和模块工作。它和程序集工作。首先，程序集是一个或多个模块/资源文件的逻辑性分组。其次，程序集是重用、安全性以
    及版本控制的最小单元。

    一些托管模块和资源（或数据）文件--->将多个托管模块和资源文件合并成程序集的工具--->该工具生成代表文件逻辑分组的一个PE
    32（+）文件。这个PE32（+）文件包含了一个名为清单的数据块。这些表描述了构成程序集的文件、程序集中的文件所实现的公开导
    出的类型，以及与程序集关联的资源或数据文件。

    编译器默认将生产的托管模块转换成程序集。也就是说，c#编译器生成的是含有清单的托管模块。对于只有一个托管模块且无资源的文
    件项目，程序集就是托管模块

    小结：
        1.1中提到CLR将托管模块中的IL（中间语言）代码，转换为CPU指令，然而其实CLR实际不和托管模块工作，而是和程序集，程序
        集将多个托管模块进行逻辑性的分组整合，这样可以更好地重用、安全性也更好，同时程序集模块中包含与引用的程序集有关的信
        息（包括他们的版本号），这些信息可以使程序集能够自描述。也就是说CLR可以判断为了执行程序集中的代码，程序集的直接依赖
        对象是什么。

#### 1.3加载公共语言运行时

    生成的每个程序集既可以是可执行应用程序EXE，也可以是DLL。当然，最终是由CLR管理这些程序集中的代码的执行。

    windows检查EXE头文件，决定是创建32位还是64位进程之后，会在进程地址空间加载MSCorEE.dll的x86,x64或者ARM版本。然后进程的
    主线程调用MSCorEE.dll中定义的一个方法。这个方法初始化CLR，加载EXE程序集，在调用其入口方法（Main）,随即，托管应用程序启
    动并运行。

#### 1.4执行程序集的代码

    如之前所述，托管程序集同时包含了元数据和IL（中间语言）代码。IL是与CPU无关的机器语言。IL比大多数的CPU机器语言都高级。可将
    IL视为一种面向对象的机器语言。

    为了执行方法，首先必须把方法的IL转换成本机CPU指令。这是CLR的JIT（just-in-time或者“即时”）编译器的职责。

    在Main方法执行之前，CLR会检测数Main的代码引用的所有类型。这导致CLR分配一个内部数据结构来管理对引用类型的访问。这个内部结构
    中，Console类型定义的每个方法都有一个对应的记录项。每个记录项都含有一个地址，根据此地址即可找到方法的实现。对这个结构初始化
    时，CLR将每个记录项都设置成（指向）包含在CLR内部的一个未编档函数，我们将该函数称为JITComplier。

    Main方法首次调用WriteLine时，JITCompiler函数会被调用。JITCompiler函数负责将IL代码编译成本机CPU指令。由于IL是“即时”编译的，
    所以通常将CLR的这个组件称为JITER或者JIT编译器。

    JITCompiler函数被调用时，他知道要调用的是哪个方法，以及具体是什么类型定义了该方法，然后，JITComplier会在定义（
    该类型）程序集的元数据中查找被调用方法的IL。接着，JITComplier验证IL代码，并将IL代码编译成本机CPU指令。本机CPU
    指令保存到动态分配的内存块中。然后JITCompiler回到CLR为类型创建的内部数据结构，找到与被调用方法对应的那条记录，
    修改最初对JITComplier的引用，使其指向内存块（其中包含了刚才编译好的本机CPU指令）的地址。最后，JITComplier函数
    跳转到内存块中的代码。这些代码正是WriteLine方法的具体实现。代码执行完毕返回时，会回到Main中的代码，并像往常一样
    继续执行。

    第二次执行WriteLine时，会直接执行内存块中的代码，跳过JITComplier函数。方法仅会在第一次调用的时候才会有一些性能损
    失，之后都无需重新验证IL并编译。

    CLR的JIT编译器会对本机代码进行优化
    VisualStudio中的

        调试 “Debug”==/optimize-和/debug:full开关：
            /optimize-:在c#编译器生成未优化的IL代码中，将包含许多的NOP（空操作）指令，还包含许多跳转到下一行代码的分
            支指令，VisulaStudio利用这些指令在调试期间提供编辑并继续的功能。另外，利用这些指令还可以在控制流程指令上
            设置断点，使代码更容易调试。

            /debug:full：会生成ProgramDatabase（PDB）文件，PDB文件帮助调试器查找局部变量并将IL指令映射到源代码。
            /debug:full告诉JIT编译器你打算调试程序集，JIT编译器会记录每条IL指令所产生的的本机代码

        发布 “Release”==/optimize+和/debug:pdbonly开关：
            /optimize+：c#编译器会删除多余的NOP和分支指令。而在控制流程被优化之后，代码就难以在调试器中进行单步调试了。
            /debug:pdbonly：不记录IL与本机代码的联机，这会使得JIT编译器运行的少块，用的内存也稍少。

    托管代码相比较于非托管代码的优势：

        1.JIT编译器能判断应用程序是否运行在Intel Pentium4 CPU上，并生成相应的本机代码来利用Pentium4支持的任何特殊指令。
        相反，非托管应用程序通常只针对具有最小功能集合的CPU编译的。

        2.JIT编译器能判断一个特定的测试在他运行的机器上是否总是失败的，例如：
            if(numberOfCPUs>1){

            } 
            如果主机只有一个CPU，JIT编译器不会为上述代码生成任何CPU指令。
        
    小结：
        在首次执行方法时，CLR会通过JIT编译器将所需执行的方法编译成CPU指令，然后存放在动态内存中，同时在调用该方法处修改引用
        指向动态内存中，这样在第二次调用时就不需要再一次的验证和编译。非托管代码一旦调用就可以直接执行，而托管代码，首先编译
        器遍历源代码，做大量的工作来生成IL代码，但想要真正的执行，这些IL代码本身必须在运行时编译成本机CPU指令，这需要分配更
        多的非共享内存，并花费额外的CPU时间。但微软在这方面做了很多的优化，同时JIT编译器也对执行环境的认识更加深刻，有很多自
        身的优势。

#### 1.4.1IL和验证

    IL：IL基于栈，这意味着他的所有指令都要将操作数压入一个执行栈，并从栈中弹出结果。IL指令是无类型的

    IL最大的优势是应用程序的健壮性和安全性。将IL编译成本及CPU指令时，CLR执行一个名为验证的过程。这个过程会检查高级IL代码，确定
    代码所做的一切都是安全的。例如，会合适调用的每个方法都有正确的参数，传递给每个方法的参数都有正确的类型，等等。托管模块的元数
    据包含验证过程要用到的所有方法及类型信息。

#### 1.4.2不安全的代码

    不安全（unsafe）代码，允许直接操作内存地址并可操作性这些地址处的字节。

    JIT编译器编译一个unsafe方法时，会接检查该方法所在的程序集是否被授予了System.Security.Permissions.SecurityPermission权限，
    而且Security.Permissions.SecurityPermissionFlag的SkipVerification标志是否设置，如何设置了则会编译，允许代码执行，如果没
    有设置则会抛出异常。

#### 1.5本机代码生成器：NGen.exe

    使用.Net Framework提供的NGen.exe工具，可以在应用程序安装到用户的计算机上时，将IL代码编译成本机代码。由于在安装时已经编译好，
    所以就不需要再运行时编译了，这有助于提高应用程序的性能。

    好处：
        1.提高应用程序的启动速度
        2.减小应用城西的工作集
    问题：
        1.没有知识产权保护
        2.NGen生成的文件可能失去同步
        3.较差的执行时性能

    小结：
        不建议使用。

#### 1.6Framework类库

    .NET Framework包含Framework类库（Framework Class Library,FCL）。FCL是一组DLL程序集的统称，其中含有数千个类型定义，每个类型
    都公开了一些功能。

    下面举例应用程序开发人员可以利用这些程序集创建的一部分应用程序.
        Web服务（Web service）
        基于HTML的Web窗体/MVC应用程序
        “富”Windows GUI应用程序
        windows控制台应用程序
        Windows服务
        数据库存储过程
        组件库

    由于FCL包含的类型数量实在太多，所以有必要将相关的类型放到单独的命名空间。为了使用Framework的任何功能，必须知道这个功能由什么类型
    提供，以及该类型包含在那个命名空间中。许多类型都运行自定义其行为，你只需要从所需的FCL类型派生出自己的类型，在进行自定义即可。下面
    总结部分常规命名空间：
        命名空间                            内容说明
        System                             包含每个应用程序都要用到的所有基本类型
        System.Data                        包含用于和数据库通信以及处理数据的类型
        System.IO                          包含用于执行流I/O以及浏览目录/文件的类型
        System.Runtime.InteropServices     包含运行托管代码访问非托管操作系统平台功能（比如Com组件）
        System.Security                    包含用于保护数据和资源的类型
        System.Text                        包含处理各种编码文本的类型
        System.Threading                   包含用于异步操作和同步资源访问的类型
        System.Xml                         包含用于处理XML架构和数据的类型

#### 1.7通用类型系统

    CLR一切都围绕类型展开，类型向应用程序和其他来写公开了功能。通过类型，用一种编程语言写的代码能与另一种沟通，由于类型是CLR的根本，所以
    Microsoft制定了一个正式的规范来描述类型的定义和行为，这就是“通用类型系统”（Common Type System,CTS）。

    CTS规范规定，一个类型可以包含零个或者多个成员
        字段
        方法
        属性
        事件

    CTS还制定了类型可见性规则以及类型成员的访问规则
        private
        family (c#中用protected修饰符来表示family)
        family and assembly (c#中没有提供这类访问)
        assembly (c#中使用internal修饰符来表示assembly)
        family or assembly (c#中用protected internal修饰符表示family or assembly)
        public

    CTS还为类型继承、虚方法、对象生存期等定义了相应的规则。

    不需要专门学习CTS规则本身，你选择的语言会采用你熟悉的方式公开他们自己的语法和规则。通过编译器来生成程序集，他会将语言特有的语法映射到
    IL（CLR的“语言”）

    CTS另一条规则：所有类型最终必须从定义的System.Object类型继承，System.Object类型运行做下面这些事。
        比较两个实例的相等性
        获取实例的哈希码
        查询一个实例的真正类型
        执行实例的浅拷贝
        获取实例对象当前状态的字符串表示

#### 1.8公共语言规范

    语言集成是一个宏伟的目标，最棘手的问题是各种编程语言存在极大区别。例如，有的语言不区分大小写，有的不支持unsigned整数、操作符重载或者
    参数数量可变的方法。

    要创建很容易从其他编程语言只能够访问的类型，只能从自己的语言中挑选出其他所有语言支持的功能。为了在这个方面提供帮助,Microsoft定义了“(
    Common Language Specification,CLS),他详细定义了一个最小功能集。任何编译器只有支持这个功能集，生成的类型才能兼容由其他符合CLS、面向
    CLR的语言生成的组件。

    CLR/CTS 支持的功能比CLS定义的多得多，CLS定义的只是一个子集。

    CLR/CTS提供了一个功能集。有的语言公开了CL/CTS的一个较大的子集。如果开发人员使用IL汇编语言写程序，可以使用CLR/CTS提供的全部功能。但是
    其他大多数语言（比如c#、VB）指向开发人员公开了CLR/CTS的一个功能自己。CLS定义了所有语言都必须支持的最小功能集。

    用一种语言定义类型时，如果希望在另一种语言中使用该类型，就不要再该类型的public和protected成员中使用位于CLS外部的任何功能。

    [assembly:CLSComplint(true)] 应用于程序集，告诉编译器检查其中的任何公开类型，判断是否存在不合适的构造阻止了从其他编程语言中访问。

    在CLR中，类型的每个成员要么是字段，要么是方法。编译器遇到枚举、数组、委托、事件等，都必须将其转换成字段和方法，使CLR和其他任何编程语言
    能够访问这些构造。

#### 1.9与非托管代码的互操作性

    .NEF Framework提供了其他平台开发没有的许多优势。但是能下定决心重新设计和重新实现全部现有代码的公司并不多。Microsoft也知道这个问题，并
    通过CLR来提供了一些机制，允许在应用程序中同时包含托管和非托管代码，具体说，支持三种操作情形。

    1.托管代码能调用DLL中的非托管函数
    2.托管代码可以使用现有的COM组件（服务器）
    3.非托管代码可以使用托管类型（服务器）
