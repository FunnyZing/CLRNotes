### 3.共享程序集和强命名程序集

#### 3.1 两种程序集，两种部署

    CLR支持两种程序集：
        弱名称程序集(weakly named assembly)
        强名称程序集(strongly named assembly)

    相同之处：
        弱命名和强命名程序集结构完全相同。PE文件格式、PE32(+)头、CLR
        头、元数据、清单表以及IL。生成的工具也相同。

    不同之处：
        强命名程序集使用发布者的公钥/私钥进行了签名。这一对秘钥允许对程序集进行唯一性的表
        示、保护和版本控制，允许程序集部署到用户机器的任何地方，甚至可以部署到Internet
        上。由于程序集被唯一性的标识，所以当应用程序绑定到强命名程序集时，CLR可以应用一些
        已知安全的策略

    程序集可以采用两种方式部署：私有或全局。

    私有部署：
        私有部署的程序集是指部署到应用程序基目录或者某个子目录的程序集。
        弱命名程序集只能以私有方式部署
    
    全局部署
        全局部署的程序集是指部署到一些公认位置的程序集。CLR在查找程序集
        时，会检查这些位置。强命名程序集既可以私有部署，也可全局部署。

#### 3.2 为程序集分配强名称

    问题：
        要由多个应用程序访问的程序集必须放到公认的目录。两个（或多个）公司可能生成具有相同
        文件名的程序集。所以，假如两个程序集都复制到了相同的公认目录，最后一个安装的就是
        “老大”，造成正在使用旧程序集的所有应用程序都无法正常工作（这就是Windows"Dllhell"
        的由来，因为共享DLL全都复制到System32目录）。

    只根据文件名来区分程序集明显不够。CLR必须支持对程序集进行唯一性标识的机制，这就是所谓
    的“强命名程序集”。

    强命名程序集具有四个重要特性，他们共同对程序集进行唯一性标识：文件名、版本号、语言文化
    和公钥。由于公钥数字很大，所以经常使用从公钥派生的小哈希值，称为公钥标记。
    
    可用辅助类System.Reflection.AssemblyName轻松构造程序集名称，并获取程序集名称的各个
    组成部分。该类提供了几个公共实例属性，比如CultureInfo,FullName,KeyPair,Name，
    Version还提供了几个公共实例方法，比如GetPublicKey,GetPublicKeyToken,SetPublicKey
    和SetPublicKeyToken

    创建强命名程序集的第一步是用.NET Framework SDK和Microsoft Visual Studio随带的Stro
    ngName实用程序（SN.exe）获取秘钥。SN.exe允许通过多个命令行开关来使用一整套功能。所有
    命令行开关都区分大小写。

    公钥标记：公钥太大，难以使用。为了简化开发人员的工作，设计出了公钥标记，公钥标记是公钥
    的64位哈希值。

    用私钥对程序集进行签名，并将公钥嵌入清单。注意只能对含有清单的程序集文件进行签名；程序
    集其他文件不能被显示签名

    “对文件进行签名”的准确含义是：生成强命名程序集，程序集的FileDef清单元数据表列出构成程
    序集的所有文件。每将一个文件名添加到清单，都对文件内容进行哈希处理。哈希值和文件名一道
    存储到FileDef表中。

    生成包含清单的PE文件后，会对PE文件的完整内容（除去Authenticode Signature、程序集强
    名称数据以及PE头校验）进行哈希处理。哈希值用发布者的私钥进行签名，得到的RSA数字签名存
    储到PE文件的一个保留区域。

    发布者公钥也嵌入PE文件的AssemblyDef清单元数据表。文件名、程序集版本号、语言文化和公钥
    的组合为这个程序集赋予了一个强名称，他保证是唯一的。到此程序集及其所有文件就可以打包和
    分发了。

    编译器在编译源代码时会检测引用的类型和成员。必须向编译器指定要应用的程序集。编译器的一
    项工作是在最终的托管模块中生成AssemblyRef元数据表，其中每个记录项窦志明被引用程序集的
    名称、版本号、语言文化和公钥信息。

#### 3.3 全局程序集缓存

    由多个应用程序访问的程序集必须放到公认的目录，而且CLR在检测到对该程序集的引用时，必须
    知道检查该目录。这个公认的位置就是全局程序集缓存（Global Assembly Cache,GAC）。GAC的
    具体位置是一种实现细节，不同的版本会有所变换。但是一般只能在以下目录中发现它：
        %SystemRoot%Microsoft.NET\Assembly
    
    GAC目录是结构化的：其中包含许多子目录，子目录的名称用算法生成。永远不要将程序集文件手
    动复制到GAC目录；相反，要用工具完成这项任务，工具知道GAC的内部结构，冰之岛如何生成正
    确的子目录名。
    在开发和测试时在GAC中安装强命名程序集最常用的工具是GACUtil.exe

    注意：不能将弱命名程序集放到GAC

    为什么要在GAC中注册程序集？
        假定两家公司都生成了名为OurLibrary的程序集，两个程序集都由一个OurLibrary.dll文件
        构成。两个文件显然不能存储到同一个目录，否则最后一个安装的会覆盖第一个。将程序集文
        件安装到GAC，就会在%SystemRoot%Microsoft.NET\Assembly目录下创建专门的子目录，
        程序集文件会复制到其中一个子目录。

#### 3.4 在生成的程序集中引用强命名程序集

    你生成的任何程序集都包含对其他强命名程序集的引用，因为System.Object在MSCorLib.dll中
    定义，后者就是强命名程序集。

    我们引用程序集如果不含指定路径CSC.exe会尝试在以下目录中查找程序集（顺序查找）：
        
        1.工作目录
        
        2.CSC.exe所在的目录，目录中还包含CLR的各种DLL文件

        3.使用/lib编译器开关指定的任何目录

        4.使用LIB环境变量指定的任何目录
    
    安装.NET Framework时，实际会安装Microsoft的程序集文件的两套拷贝。一套安装到编译器/CL
    R目录，另一套安装到GAC的子目录。编译器/CLR目录中的文件方便你生成程序集，而GAC中的拷贝
    则方便在运行时加载。

#### 3.5 强命名程序集能防篡改

    用私钥对程序集进行签名，并将公钥和签名嵌入程序集，CLR就可验证程序集未被修改或破坏。程
    序集安装到GAC时，系统对包含清单的那个文件的内容进行哈希处理，将哈希值与PE文件中嵌入的
    RSA数字签名进行比较，如果两个哈希值完全一致，表明文件内容未被修改。此外，系统还对程序
    集的其他文件的内容进行哈希处理，并将哈希值与清单文件的FileDef表中存储的哈希值进行比较
    任何一个哈希值不匹配，表明程序集至少有一个文件被篡改，程序集将无法安装到GAC

    应用程序需要绑定到程序集是，CLR根据被引用程序集的属性（名称、版本、语言文化和公钥）在
    GAC中定位该程序集。找到被引用程序集，就返回包含他的子目录，并加载清单所在的文件。

    将强命名程序集文件安装到GAC时，系统会执行检查，确保包含清单的文件没有被篡改。这个检查
    仅在安装时执行一次。相反，从非GAC的目录加载强命名程序集时，CLR会校验程序集的清单文件，
    确保文件内容未被篡改，造成该文件每次加载都造成额外的性能开销

#### 3.6 延迟签名

    准备打包自己的强命名程序集时，必须使用受严密保护的私钥对他进行签名，然而，在开发和测试
    程序集时，访问这些受严密保护的私钥可能有点碍事。有鉴于此，.NET Framework提供了对延迟
    签名的支持，该技术也称为部分签名。

    延迟签名允许只用公司的公钥生成程序集，暂时不用私钥。由于使用了公钥，引用了程序集的其他
    程序集会在他们的AsemblyRef元数据表的记录项中嵌入正确的公钥值。另外他还使程序集能正确
    存储到GAC的内部结构中。

#### 3.7 私有部署强命名程序集

    虽然强命名程序集能安装到GAC，但绝非必须。事实上，只有由多个应用程序共享的程序集才应该
    部署到GAC。不用共享的应该私有部署。私有部署达成了“简单复制部署”目标，而且能更好的隔离
    应用程序及其程序集。另外不要将GAC想象成新的C:\Windows\System32垃圾堆积场。这是因为新
    版本的程序集不会相互覆盖，他们并行安装，每个安装都占用磁盘空间。

#### 3.8 “运行时”如何解析类型引用

    public sealed class Program{
        public statifc void Main{
            System.Console.WriteLine("Hi");
        }
    }

    编译这些代码并生成程序集（假定名为Program.exe）运行应用程序，CLR会加载并初始化自身，
    读取程序集的CLR头，查找标识了应用程序入口方法Main的MethodDefToken，检索MethodDef元
    数据表找到方法IL代码在文件中的偏移量，将IL代码JIT编译成本机代码（编译时会对代码进行验
    证安全以确保类型安全），最后执行本机代码。

    对这些代码进行JIT编译，CLR会检测所有类型成员引用，加载它们的定义程序集（如果尚未加载）
    上述IL代码包含对System.Console.WriteLine的引用。具体地说：
        首先IL call指令引用了元数据token 0A000003。该token标识MemberRef元数据表中记录的项3，然后CLR检查该MemberRef记录项，发现他的字段引用了TypeRef表中的记录System.
        Console类型。按照TypeRef记录项，CLR被引导至一个AssemblyRef记录项：
        “mscorlib,Version=4.0.0.0,Culture=neutral,PublicKeyToken=b77a5c561934e089”
        这时CLR就知道了他需要的是哪个程序集。接着CLR必须定位并加载该程序集。
    
    在上列中，CLR发现System.Console在和调用者不用的程序集中实现。所以，CLR必须查找那个程
    序集，加载包含程序集清淡的PE文件。然后扫描清单，判断是那个PE文件实现了类型。如果被引用
    的类型就在清单文件中，一切都很简单。如果类型在程序集的另外一个文件中，CLR必须加载那个
    文件，并扫描其元数据来定位类型。然后，CLR创建它的内部数据结构来表示类型，JIT编译器完成
    Main方法的编译。最后，Main方法开始执行。

    注意
        对于CLR，所有程序集都根据名称、版本、语言文化和公钥来识别。但GAC根据名称、版本、
        语言文化、公钥和CPU架构来识别的。在GAC中搜索程序集时，CLR判断应用程序当前在什么
        类型的进程中运行。

#### 3.9 高级管理控制（配置）

    CLR可以通过应用程序的XML配置文件来定位发生移动的文件

    编译方法时，CLR判断它引用了那些类型和成员。根据这些信息，“运行时”检查进行引用的程序集
    的AssemblyRef表，判断程序集生成时引用了那些程序集。然后CLR在应用程序配置文件中检查程
    序集/版本，进行指定的版本号重定向操作。随后，CLR查找新的、重定向的程序集/版本。
   

