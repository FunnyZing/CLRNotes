### 5 基元类型、引用类型和值类型

#### 5.1 编程语言的基元类型

    编译器直接支持的数据类型称为基元类型。基元类型直接映射到Framework类库中存在的类型。例
    如，C#的int直接映射到System.Int32类型。因此，以下4行代码都能正确编译，并生成完全相同
    的IL：
        int a=0;
        System.Int32 a=0;
        int a=new int();
        System.Int32 a=new System.Int32();
    从另一个角度可以认为，C#编译器自动假定所有源代码文件都添加了一下using指令：
        using sbyte=System.SByte;
        using byte=System.Byte;
        ...

    在许多语言中，以下代码可以正确编译并运行：
    Int32 i=5;
    Int64 l=i;
    但这根据之前对类型转换的讨论，我们会认为上述代码无法编译。因为System.Int32和System.I
    nt64是不同的类型，相互不存在派生关系。但事实上，c#编译器正确编译了上述代码，运行起来也
    没有问题。这是因为，c#编译器非常熟悉基元类型，会在编译代码时应用自己的特殊规则。也就是
    说，编译器能识别常见的编程模式，并生成必要的IL，使写好的代码能像预期的那样工作。具体的
    说，c#编译器支持与类型转换、字面值以及操作符有关的模式。

    首先，编译器能执行基元类型之间的隐式或显示转换，只有在转换“安全”的时候，c#才允许隐式转
    型。所谓“安全”，是指不会发生数据丢失的情况，比如从Int32转换为Int64。但如果可能不安全
    C#就要求显示转型。

    checked和unchecked基元类型操作
        c#通过checked和unchecked操作符来控制溢出检查
            UInt32 invalid=unchecked((UInt32)(-1));
            
            Byte b=100;
            b=checked((Byte)(b+200));

            checked{
                Byte b=100;
                b=(Byte)(b+200);
            }
    提示1：
        由于checked操作符和checked语句唯一的作用就是决定生成那个版本的加、减、乘和数据转
        换IL指令，所以在checked操作符或语句中调用方法，不会对该方法造成任何影响，如下：
            checked{
                //假定SomeMethod试图把400加载到一个Byte中
                SomeMethod(400);
                //SomeMethod可能会、也可能不会抛异常
                //如果SomeMethod使用checked指令编译，就可能会抛出异常
                //但这和当前的checked语句无关
            }

    提示2：
        System.Decimal是非常特殊的类型。虽然许多编程语言将Decimal视为基元类型，但CLR不然
        这意味着CLR没有知道如何处理Decimal值得IL指令。Decimal类型提供了一系列public sta
        tic方法来进行操作。
        编译使用了Decimal值得程序时，编译器会生成代码来调用Decimal的成员，并通过这些成员
        来执行实际的运算。这意味着Decimal值得吃力速度慢于CLR基元类型的值。checked和unche
        cked也是无效的。所以如果他执行不安全的运行，肯定会抛出OverflowException异常。

#### 5.2 引用类型和值类型

    CLR支持两种类型：引用类型和值类型。引用类型总是从托管堆分配，c#的new操作符返回对象内存
                    地址————即指向对象数据的内存地址。

    引用类型：

        1. 内存必须从托管堆分配

        2. 堆上分配的每个对象都有一些额外成员，这些成员必须初始化

        3. 对象中的其他字节（为字段而设）总设为零

        4.从托管堆分配对象时，可能强制执行一次垃圾回收。
    
    如果所有类型都是引用类型，应用程序的先将显著下降。为了提升简单和常用的性能，CLR提供了
    名为“值类型”的轻量级类型。值类型的实例一般在线程栈上分配。在代表值类型实例的变量中不包
    含指向实例的指针。相反，变量中包含了实例本身的字段。由于变量已包含了实例的字段，所以操
    作实例中的字段不需要提领指针。值类型的实例不受垃圾回收器的控制。因此，值类型的使用缓解
    了托管堆的压力，并减少了应用程序生存期内的垃圾回收次数。

    在文档中查看类型时，任何称为“类”的类型都是引用类型。相反，所有值类型都称为结构或枚举。
    进一步研究文档，会发现所有结构都是抽象类型System.ValueType的直接派生类。System.Value
    Type本身又直接从System.Object派生。根据定义，所有值类型都必须从System.ValueType派生
    所有枚举都从System.Enum抽象类型派生，后者又从System.ValueType派生。

    struct SomeVal{ public Int32 x; }

    SomeVal v1 和 SomeVal v1=new SomeVal()的区别：
        如果使用new操作符，c#会认为实例已初始化

    设计自己的类型时，要仔细考虑类型是否应该定义成值类型而不是引用类型。值类型有时能提供更
    好的性能，具体的说，除非满足以下全部条件，否则不应将类型声明为值类型。

        1.类型具有基元类型的行为。
        2.类型不需要从其他任何类型继承
        3.类型也不派生出其他任何类型

    同时也应该考虑类型的大小，应为实参默认以值传递方式传递，造成对值类型实例中的字段进行复
    制，对性能有损害。同样的，被定义为返回一个值类型的方法在返回时，实例中的字段会复制到调
    用着分配的内存中，对性能造成损害。所以，要将类型声明为值类型，除了要满足以上全部条件，
    还必须满足以下任意条件。

        1.类型的实例较小（16字节或者更小）
        2.类型的实例较大（16字节或者更大），但不作为方法实参传递，也不从方法返回。

    值类型与引用类型区别：

        1.值类型对象有两种表示形式：未装箱和已装箱。引用类型总是处于装箱形式
        
        2.值类型从System.ValueType派生。该类型提供了与System.Object相同的方法。但Syste
          m.ValueType重写了Equals方法。
        
        3.由于不能将值类型作为基类型来定义新的值类型或者新的引用类型，所以不应在值类型中引
          任何新的虚方法。所有的方法都不能是抽象的，所有的方法都隐式密封（不可重写）
        
        4.引用类型的变量包含堆中对象的地址。引用类型变量创建时默认初始化为null,表明当前不
          指向有效对象。相反，值类型的变量总是包含基础类型的一个值，而且值类型的所有成员都
          初始化为0

        5.将值类型变量赋给另一个值类型变量，会执行逐字段的复制。将引用类型的变量赋给另一个
          引用类型的变量只复制内存地址。

        6.两个或者多个引用类型变量能引用堆中同一个对象，所以对一个变量执行的操作可能影响到
          另一个变量引用的对象。

        7.由于未装箱的值类型不在堆上分配，一旦定义了该类型的一个实例方法不在活动，为他们分
          配的内存就会释放，而不是等着垃圾回收。

#### 5.3 值类型的装箱和拆箱

    值类型比引用类型轻，原因是他们不作为对象在托管堆中分配，不被垃圾回收，也不通过指针进行
    引用。但许多时候都需要获取对值类型实例的引用。例如

        struct Point{
            public Int32 x,y;
        }

        public sealed class Program{
            public static void Main(){
                ArrayList a=new ArrayList();
                Point p;
                a.add(p);
            }
        }
    
    上列中将Point存储到ArrayList中，但问题是ArrayList中究竟存储了什么？是Point结构，Poi
    nt结构的地址，还是其他的定西。要知道这个问题，我们需要讨论一下ArrayList的Add方法。

        public virtual Int32 Add(Object value);

    Add获取的是一个Object参数，也就是说，Add获取对托管对上的一个对象的引用来作为参数。但
    之前传递的是Point,一个值类型。为了使代码正确工作，Point值类型必须转换成在堆中托管的对
    象，而且必须获取对该对象的引用。

    将值类型转换成引用类型要是用装箱机制。下面总结了装箱时所发生的的事情、

        1.在托管堆中分配内存。分配的内存量是值类型各字段所需的内存量，还要加上托管堆所有对
        象都有的两个额外成员（类型对象指针和同步块索引）所需的内存量

        2.值类型的字段复制到新分配的堆内存

        3.返回对象地址。现在该地址是对象引用

    Point p = (Point) a[0];

    获取ArrayList的元素0包含的引用，试图将其放到Point值类型的实例p中。为此，已装箱Point
    对象中的所有字段都必须复制到值类型变量p中，后者在线程栈上。CLR分两步完成复制。第一步获
    取已装箱Point对象中的各个Point字段的地址，这个过程称为拆箱。第二步将字段包含的值从堆
    复制到基于栈的值类型实例中。

    拆箱不是直接将装箱过程倒过来。拆箱的代价比装箱低得多。拆箱其实就是获取指针的过程，该指
    针指向包含在一个对象中的原始值类型。其实，指针指向的是已装箱实例中的未装箱部分。所以和
    装箱不同，拆箱不要求在内存中复制任何字节。往往紧接着拆箱发生一次字段复制。

    已装箱的值类型实例在拆箱时，内部发生下面这些事情

        1.如果包含“对已装箱值类型实例的引用”的变量为null，抛出异常

        2.如果引用的对象不是所需值类型的已装箱实例，抛出异常

    有的语言（比如c++）允许在不复制字段的前提下对已装箱的值类型进行拆箱。拆箱返回已装箱对
    象中的未装箱部分的地址。接着可利用这个指针来操纵未装箱的实例字段。

    简单的说，要获取对值类型实例的引用，实例就必须装箱。

    未装箱值类型比引用类型更“轻”。原因如下：
        
        1.不在托管堆上分配

        2.没有堆上的每个对象都有的额外成员：“类型对象指针”和“同步块索引”
    
    由于未装箱值类型没有同步块索引，所以不能用System.Threading.Monitor类型的方法让多个线
    程同步对实例的访问。

    虽然未装箱值类型没有类型对象指针，但仍可调用由类型继承或重写的虚方法（比如Equals，Ge
    tHashCode或者ToString）。如果值类型重写了其中任何虚方法，那么CLR可以非虚地调用该方法
    因为值类型隐式密封，不可能有类型从他们派生，而且调用虚方法的值类型实例没有装箱。然而如
    果重写的虚方法要调用方法在基类中的实现，那么在调用基类的实现时，值类型实例会装箱，以便
    能够通过this指针将对一个堆对象的引用传给基方法。

    但在调用非虚地、继承的方法时（比如GetType或MemberwiseClone），无论如何都要对值类型进
    行装箱。因为这些方法由System.Object定义，要求this实参是指向堆对象的指针。

    此外，将值类型的未装箱实例转型为类型的某个接口时要对实例进行装箱。这是因为接口变量必须
    包含对堆对象的引用。

    

